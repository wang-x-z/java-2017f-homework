# 说明文档

------
## 设计理念

对前两次作业的优化和改版，基于example。<br>
1. 首先对所有角色将其抽象成生物体接口**Creature**，声明共用方法。实例化各个对象。<br>
2. 对列阵声明一个接口**Order**和方法`rank()`，过程中为了方便代码复用增加了static方法`addPos()`。方便后期增加阵势。<br>
3. 列阵类**Embattle**中包含了对角色的处理，包括初始化局面，添加角色，打乱葫芦娃兄弟的排序等。<br>
4. 调用`Crane().rank()`和`Arrow().rank()`实现两种情况下不同的阵势。具体实现时对葫芦娃兄弟、爷爷、蝎子精、蛇精、小喽啰都进行了排布。<br>
5. 切换阵势时将局面上记录角色和位置的链表清空。<br>
6. 实现`show()`函数打印局面。<br>

## 面向对象概念

1. 把葫芦娃、爷爷等角色抽象成生物**Creature**，七兄弟和小喽啰等作为该类的**对象**是该类的**实例化**，有向类传递消息的**方法**，具体表现为`setPosition(), getPosition()`等函数实现。此次作业中每个对象采用的都是默认构造器创建。<br>
2. 另一个接口是**Order**。因为列阵方式有多种（包括鹤形、箭矢形等），小喽啰可能随时变换更多的阵势，采用接口方便后续对阵势的补充。<br>

## 面向对象机制

###  封装

对认为是私有的属性用**private**隐藏信息，比如每个生物体对象的位置(`position`)、坐标，以及整个局面的排布情况(数组`arr[][]`)，在类内部实现细节。同时必要时候提供了get或set等方法提供给外界访问或修改数据(比如`getPositions(), getCreatures()`等)。

###  继承

1. Huluwa, Grandpa, Scorpion, Snake, Lackey继承自Creature接口。Crane, Arrow继承自Order接口，实现鹤形和箭矢形列阵。<br>
2. 因为类都是继承自终极基类**Object**，通过`super()`调用基类版本构造器(比如Position类构造器)。<br>
3. 在处理局面时，所有生物体(包括葫芦娃、小喽啰等)都**向上转型**为**Creature**。<br>

###  多态

继承自**Creature**接口的所有对象都重写**Creature**中声明的`setPosition()`和`getPosition()`，并且都有自己的方法函数。
**Arrow**和**Crane**类中重写接口**Order**的`rank()`函数，并且调用了**Order**接口中**static**方法`addPos()`。
**向上转型**后每个对象都看做是一个**Creature**，实际操作时调用具体对象方法(如`show()`打印各个对象名称)。
