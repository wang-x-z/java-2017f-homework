# 说明文档

-----


## 面向对象机制

* **抽象**

#### 分析整个游戏场景，抽象出**Creature**,**Queue**,**Camp**,**Sorter**四个基类分别描述场景中的人物，队列，阵营，排序方法，再从基类中派生出子类，实现一些更具体的功能。使得程序模块清晰。
 

* **封装**

#### 封装包括过程封装和数据封装，如Position中的x，y都是private属性，但是可以通过`getx()`,`gety()`成员函数获得信息。使得对象的信息被保护。


* **继承**
 
#### 1. Huluwa, Grandpa, Scorpion, Snake, Monstor继承Creature基类。Crane, Arrow继承自Queue类，实现鹤形和箭矢形列阵。BadCamp,GoodCamp继承Camp类，实现两大阵营对峙。
#### 2. 因为类都是继承自终极基类**Object**，通过`super()`调用基类版本构造器(比如Position类构造器)。
 
 
* **多态**
 
#### 比如继承自**Creature**基类的所有对象都重写**Creature**中声明的`report()`函数，以实现不同人物的报数方式，即每个对象都看做是一个**Creature**，实际操作时调用具体对象方法。多态使得程序编写更加简洁方便。


## 设计理念

#### 1.遵守单一职责原则，将不同的职责封装到不同的类或模块中。
#### 2.遵循LOD原则，当其中某一个模块发生修改时，尽量少地影响其他模块，扩展会相对容易通信的限制，通过限制实体之间通信的宽度和深度，降低系统的耦合度，使类与类之间保持松散的耦合关系。
